def search(query: str) -> str:
    """
    ä½¿ç”¨ DuckDuckGo æ‰§è¡Œç½‘é¡µæœç´¢å¹¶æ ¼å¼åŒ–ç»“æœã€‚
    å¤±è´¥æ—¶ä¼šé‡è¯•ä¸€æ¬¡ã€‚
    """
    for attempt in range(2):
        try:
            with DDGS() as ddgs:
                results = list(ddgs.text(query, max_results=10))
            
            if not results:
                return "No search results found."
            
            formatted = []
            for i, res in enumerate(results, 1):
                title = res.get('title', 'No title').encode('utf-8', 'ignore').decode('utf-8')
                body = res.get('body', 'No summary').encode('utf-8', 'ignore').decode('utf-8')
                href = res.get('href', 'No link')
                formatted.append(f"{i}. {title}\n   {body[:150]}...\n   {href}")
                
            return "Search Results:\n" + "\n\n".join(formatted)
            print(f"Search attempt {attempt  + 1} failed: {e}. Retrying in 2 seconds...")
        except Exception as e:
            time.sleep(2)
            
    return "Search error: Exceeded maximum retries."

# ============================================
# ä¸»è¦å·¥å…·å‡½æ•°
# ============================================
def get_stock_price(ticker: str) -> str:
    """è·å–è‚¡ç¥¨å½“å‰ä»·æ ¼å’Œå˜åŒ–"""
    time.sleep(1)
    try:
        stock = yf.Ticker(ticker)
        hist = stock.history(period="5d")
        if hist.empty or len(hist) < 2:
            raise ValueError("Historical data is insufficient")
        
        current_price = hist['Close'].iloc[-1]
        prev_close = hist['Close'].iloc[-2]
        
        change = current_price - prev_close
        change_percent = (change / prev_close) * 100
        
        return f"{ticker} Current Price: ${current_price:.2f} | Change: ${change:.2f} ({change_percent:+.2f}%)"
    except Exception as e:
        return f"Error fetching price for {ticker}: {str(e)}. Please use the search function."

def get_company_info(ticker: str) -> str:
    """
    ä» Yahoo Finance è·å–å…¬å¸èµ„æ–™ä¿¡æ¯ã€‚
    å¤±è´¥æ—¶å›é€€åˆ°ç½‘é¡µæœç´¢ã€‚
    """
    try:
        stock = yf.Ticker(ticker)
        info = stock.info
        
        if not info or 'longName' not in info:
            raise ValueError(f"'{ticker}' information is incomplete, possibly invalid ticker.")
            
        summary = info.get('longBusinessSummary')
        description = (summary[:200] + '...') if summary else 'No description'
        
        result = f"""Company Profile ({ticker}):
- Name: {info.get('longName', 'Unknown')}
- Sector: {info.get('sector', 'Unknown')}
- Industry: {info.get('industry', 'Unknown')}
- Market Cap: ${info.get('marketCap', 0):,.0f}
- Trailing PE: {info.get('trailingPE', 'Unknown')}
- Forward PE: {info.get('forwardPE', 'Unknown')}
- Description: {description}"""
        return result
    except Exception as e:
        print(f"yfinance fetch for '{ticker}' failed: {e}. Falling back to web search.")
        return search(f"{ticker} company profile")

def get_company_news(ticker: str) -> str:
    """
    ä½¿ç”¨ yfinance è·å–å…¬å¸æ–°é—»ï¼Œå¢åŠ äº†é‡è¯•æœºåˆ¶ã€‚
    å¦‚æœå¤šæ¬¡å°è¯•åä»å¤±è´¥ï¼Œåˆ™å›é€€åˆ°é€šç”¨æœç´¢ã€‚
    """
    max_retries = 2
    for attempt in range(max_retries):
        try:
            stock = yf.Ticker(ticker)
            news = stock.news
            
            if news:
                recent_news = news[:5]
                news_list = []
                for i, article in enumerate(recent_news, 1):
                    title = article.get('title', 'No title')
                    publisher = article.get('publisher', 'Unknown source')
                    pub_time = article.get('providerPublishTime', 0)
                    date_str = datetime.fromtimestamp(pub_time).strftime('%Y-%m-%d') if pub_time else 'Unknown date'
                    news_list.append(f"{i}. [{date_str}] {title} ({publisher})")

                return f"Latest News ({ticker}):\n" + "\n".join(news_list)
            
            print(f"Warning: yfinance.news returned empty list for {ticker} (attempt {attempt + 1}/{max_retries})")
            time.sleep(2)
        except Exception as e:
            print(f"Error: Exception fetching news for {ticker} (attempt {attempt + 1}/{max_retries}): {e}")
            time.sleep(2)

    print(f"Info: yfinance.news failed, falling back to search for {ticker}")
    return search(f"{ticker} latest news")

def get_market_sentiment() -> str:
    """
    è·å–å¸‚åœºæƒ…ç»ªæŒ‡æ ‡ - CNN Fear & Greed Indexã€‚
    ä½¿ç”¨å¤šç§æ–¹æ³•å°è¯•æŠ“å–ï¼Œæä¾›å¤‡ç”¨æ–¹æ¡ˆã€‚
    """
    # æ–¹æ³•1: å°è¯•æŠ“å–CNN JSON API (æœ€å¯é )
    try:
        url = "https://production.dataviz.cnn.io/index/fearandgreed/graphdata"
        response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'}, timeout=10)
        response.raise_for_status()
        data = response.json()
        score = float(data['fear_and_greed']['score'])
        rating = data['fear_and_greed']['rating']
        return f"CNN Fear & Greed Index: {score:.1f} ({rating})"
    except Exception as e:
        print(f"Method 1 (CNN API) failed: {e}. Trying fallback.")
    
    # æ–¹æ³•2: ä½¿ç”¨æœç´¢ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
    try:
        search_result = search("CNN Fear and Greed Index current value today")
        match = re.search(r'(?:Index|Score)[:\s]*(\d+\.?\d*)\s*\((\w+\s?\w*)\)', search_result, re.IGNORECASE)
        if match:
            score = float(match.group(1))
            rating = match.group(2)
            return f"CNN Fear & Greed Index (via search): {score:.1f} ({rating})"
    except Exception as e:
        print(f"Method 2 (Search) failed: {e}")
    
    return "Fear & Greed Index: Unable to fetch. Please check https://money.cnn.com/data/fear-and-greed/ manually."

def get_economic_events() -> str:
    """æœç´¢å½“å‰æœˆä»½çš„ä¸»è¦ç¾å›½ç»æµäº‹ä»¶ã€‚"""
    now = datetime.now()
    query = f"major upcoming US economic events {now.strftime('%B %Y')} (FOMC, CPI, jobs report)"
    raw_search = search(query)
    
    events_found = re.findall(r'(?:FOMC|CPI|Non-Farm|Jobs Report|Unemployment Rate).*?(?:on|date)?[\s:]*(\w+\s+\d{1,2})', raw_search, re.IGNORECASE)
    
    if events_found:
        result = f"ğŸ“… Major Economic Events for {now.strftime('%B %Y')}:\n"
        # ä½¿ç”¨å­—å…¸å»é‡å¹¶ä¿ç•™é¡ºåº
        unique_events = list(dict.fromkeys(events_found))
        for event in unique_events:
            result += f"  - {event}\n"
        return result
    
    return "Unable to parse specific event dates from search results. Please check a financial calendar for details."

def get_performance_comparison(tickers: dict) -> str:
    """
    æ¯”è¾ƒå­—å…¸ä¸­è‚¡ç¥¨ä»£ç çš„å¹´åˆè‡³ä»Šå’Œ1å¹´æœŸè¡¨ç°ã€‚
    tickers æ ¼å¼: {"Display Name": "TICKER"}
    """
    data = {}
    for name, ticker in tickers.items():
        time.sleep(1)
        try:
            stock = yf.Ticker(ticker)
            hist = stock.history(period="2y")
            if hist.empty:
                print(f"Warning: No historical data for {ticker}")
                continue
            
            end_price = hist['Close'].iloc[-1]
            
            # YTD Performance
            current_year_data = hist[hist.index.year == datetime.now().year]
            if current_year_data.empty:
                perf_ytd = float('nan') # Not enough data
            else:
                current_year_start_price = current_year_data['Close'].iloc[0]
                perf_ytd = ((end_price - current_year_start_price) / current_year_start_price) * 100
            
            # 1-Year Performance
            if len(hist) >= 252:
                one_year_ago_price = hist['Close'].iloc[-252]
                perf_1y = ((end_price - one_year_ago_price) / one_year_ago_price) * 100
            else:
                perf_1y = float('nan') # Not enough data

            data[name] = {"Current": f"{end_price:,.2f}", "YTD": f"{perf_ytd:+.2f}%", "1-Year": f"{perf_1y:+.2f}%"}
        except Exception as e:
            print(f"Error processing performance for '{ticker}': {e}")
            data[name] = {"Current": "N/A", "YTD": "N/A", "1-Year": "N/A"}
    
    if not data:
        return "Unable to fetch performance data."
            
    header = f"{'Ticker':<25} {'Current Price':<15} {'YTD %':<12} {'1-Year %':<12}\n" + "-" * 67 + "\n"
    rows = [f"{name:<25} {metrics['Current']:<15} {metrics['YTD']:<12} {metrics['1-Year']:<12}" for name, metrics in data.items()]
    return "Performance Comparison:\n\n" + header + "\n".join(rows)

def analyze_historical_drawdowns(ticker: str = "^IXIC") -> str:
    """è®¡ç®—å¹¶æŠ¥å‘Šè¿‡å»10å¹´çš„å‰3å¤§å†å²å›æ’¤ã€‚"""
    try:
        stock = yf.Ticker(ticker)
        hist = stock.history(period="10y")
        if hist.empty:
            return f"No historical data for {ticker}."
            
        hist['cummax'] = hist['Close'].cummax()
        hist['drawdown'] = (hist['Close'] - hist['cummax']) / hist['cummax']
        
        drawdowns, in_drawdown = [], False
        start_date, peak_val, min_val = None, 0, 0
        
        for i in range(len(hist)):
            current_dd = hist['drawdown'].iloc[i]
            if current_dd < 0 and not in_drawdown:
                in_drawdown = True
                start_date = hist.index[i-1] if i > 0 else hist.index[i]
                peak_val = hist['Close'].iloc[i-1] if i > 0 else hist['Close'].iloc[i]
                min_val = hist['Close'].iloc[i]
            elif current_dd < 0 and in_drawdown and hist['Close'].iloc[i] < min_val:
                min_val = hist['Close'].iloc[i]
            elif current_dd == 0 and in_drawdown:
                in_drawdown = False
                drawdowns.append({
                    "start": start_date, "end": hist.index[i],
                    "drawdown": (min_val - peak_val) / peak_val,
                    "recovery_days": (hist.index[i] - start_date).days
                })
        
        if in_drawdown:
            drawdowns.append({
                "start": start_date, "end": None,
                "drawdown": (min_val - peak_val) / peak_val, "recovery_days": "Ongoing"
            })
            
        if not drawdowns:
            return f"No significant drawdowns found for {ticker}."
            
        top_3 = sorted(drawdowns, key=lambda x: x['drawdown'])[:3]
        
        result = [f"Top 3 Historical Drawdowns for {ticker}:\n"]
        for i, dd in enumerate(top_3, 1):
            end_str = dd['end'].strftime('%Y-%m-%d') if dd['end'] else 'Ongoing'
            result.append(
                f"{i}. {dd['start'].year}  Event: Max Drawdown {dd['drawdown']:.2%} | "
                f"Recovery: {dd['recovery_days']} days ({dd['start'].strftime('%Y-%m-%d')} to {end_str})"
            )
        return "\n".join(result)
    except Exception as e:
        return f"Historical analysis error: {e}."

def get_current_datetime() -> str:
    """è¿”å›å½“å‰æ—¥æœŸå’Œæ—¶é—´"""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")